<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en"><head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/"><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>Public Key-Based Kerberos Cross Realm Path Traversal Protocol Using Kerberized Certification Authorities (kx509) and PKINIT</title><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
  margin-right: 2em;
}
cite {
  font-style: normal;
}
dl {
  margin-left: 2em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h3, h4, h5, h6 {
  font-size: 10pt;
  page-break-after: avoid;
}
h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
}
ol {
  margin-left: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
  page-break-inside: avoid;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap; 
}
table.header td {
  background-color: gray;
  width: 50%;
}
table.header a {
  color: white;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}

.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}


@media print {
  .noprint {
    display: none;
  }
  
  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a::after {
    content: leader('.') target-counter(attr(href), page);
  }
  
  ul.ind li li a {
    content: target-counter(attr(href), page);
  }
  
  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "Internet-Draft"; 
  } 
  @top-right {
       content: "August 2013"; 
  } 
  @top-center {
       content: "PKCROSS"; 
  } 
  @bottom-left {
       content: "Williams"; 
  } 
  @bottom-center {
       content: "Expires February 24, 2014"; 
  } 
  @bottom-right {
       content: "[Page " counter(page) "]"; 
  } 
}

@page:first { 
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 The Protocol" href="#rfc.section.2"><link rel="Chapter" title="3 Security Properties" href="#rfc.section.3"><link rel="Chapter" title="4 Using DANE (DNSSEC) for Realm Certificate Validation" href="#rfc.section.4"><link rel="Chapter" title="5 Application Programming Interface Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6"><link rel="Chapter" title="7 IANA Considerations" href="#rfc.section.7"><link rel="Chapter" title="8 Acknowledgements" href="#rfc.section.8"><link rel="Chapter" href="#rfc.section.9" title="9 References"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.580, 2012-06-03 11:18:18, XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dct" href="http://purl.org/dc/terms/"><meta name="dct.creator" content="Williams, N."><meta name="dct.identifier" content="urn:ietf:id:draft-williams-kitten-krb5-pkcross-03"><meta name="dct.issued" scheme="ISO8601" content="2013-08-23"><meta name="dct.abstract" content="This document specifies a protocol for obtaining cross-realm Kerberos tickets using existing, related protocols: kerberized certification authorities (kx509) and public key cryptography initial authentication in Kerberos (PKINIT). The resulting protocol has a number of desirable security properties, including privacy protection for the user relative to their home realm's infrastructure, as well a support for leap-of-faith trust establishment, and automated cross-realm keying. This protocol allows Kerberos to scale to large numbers of realms."><meta name="description" content="This document specifies a protocol for obtaining cross-realm Kerberos tickets using existing, related protocols: kerberized certification authorities (kx509) and public key cryptography initial authentication in Kerberos (PKINIT). The resulting protocol has a number of desirable security properties, including privacy protection for the user relative to their home realm's infrastructure, as well a support for leap-of-faith trust establishment, and automated cross-realm keying. This protocol allows Kerberos to scale to large numbers of realms."></head><body><table class="header"><tbody><tr><td class="left">Network Working Group</td><td class="right">N. Williams</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Cryptonector</td></tr><tr><td class="left">Intended status: Standards Track</td><td class="right">August 23, 2013</td></tr><tr><td class="left">Expires: February 24, 2014</td><td class="right"></td></tr></tbody></table><p class="title">Public Key-Based Kerberos Cross Realm Path Traversal Protocol Using Kerberized Certification Authorities (kx509) and PKINIT<br><span class="filename">draft-williams-kitten-krb5-pkcross-03</span></p><h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1><p>This document specifies a protocol for obtaining cross-realm Kerberos tickets using existing, related protocols: kerberized certification authorities (kx509) and public key cryptography initial authentication in Kerberos (PKINIT). The resulting protocol has a number of desirable security properties, including privacy protection for the user relative to their home realm's infrastructure, as well a support for leap-of-faith trust establishment, and automated cross-realm keying. This protocol allows Kerberos to scale to large numbers of realms.</p><h1><a id="rfc.status" href="#rfc.status">Status of this Memo</a></h1><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as &#8220;work in progress&#8221;.</p><p>This Internet-Draft will expire on February 24, 2014.</p><h1><a id="rfc.copyrightnotice" href="#rfc.copyrightnotice">Copyright Notice</a></h1><p>Copyright © 2013 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p><hr class="noprint"><h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1><ul class="toc"><li>1.&nbsp;&nbsp;&nbsp;<a href="#d1e312">Introduction</a><ul><li>1.1&nbsp;&nbsp;&nbsp;<a href="#d1e336">Conventions used in this document</a></li></ul></li><li>2.&nbsp;&nbsp;&nbsp;<a href="#d1e352">The Protocol</a><ul><li>2.1&nbsp;&nbsp;&nbsp;<a href="#d1e401">Exchange of Long-Term Cross-Realm Symmetric Keys</a><ul><li>2.1.1&nbsp;&nbsp;&nbsp;<a href="#d1e417">Caching of PKCROSS Symmetrically-Keyed Cross-Realm Principals</a></li></ul></li><li>2.2&nbsp;&nbsp;&nbsp;<a href="#d1e426">Indication of Preference for/ Required Use of Symmetrically-Keyed Cross-Realm Principals</a></li></ul></li><li>3.&nbsp;&nbsp;&nbsp;<a href="#d1e441">Security Properties</a><ul><li>3.1&nbsp;&nbsp;&nbsp;<a href="#d1e450">Automated Cross-Realm Keying</a></li><li>3.2&nbsp;&nbsp;&nbsp;<a href="#d1e459">Scalability and Vulnerability to Trusted Third Parties (TTPs)</a></li><li>3.3&nbsp;&nbsp;&nbsp;<a href="#d1e481">Privacy Protection relative to home realm</a></li><li>3.4&nbsp;&nbsp;&nbsp;<a href="#d1e508">Leap-of-Faith (LoF) / Trust-On-First-Use (TOFU)</a><ul><li>3.4.1&nbsp;&nbsp;&nbsp;<a href="#sub_Requirements_for_LoF_TOFU">Requirements and Recommendations for LoF/TOFU Authentication</a></li></ul></li></ul></li><li>4.&nbsp;&nbsp;&nbsp;<a href="#d1e544">Using DANE (DNSSEC) for Realm Certificate Validation</a></li><li>5.&nbsp;&nbsp;&nbsp;<a href="#d1e569">Application Programming Interface Considerations</a><ul><li>5.1&nbsp;&nbsp;&nbsp;<a href="#sub_API_Considerations_for">API Considerations for LoF/TOFU Authentication</a></li><li>5.2&nbsp;&nbsp;&nbsp;<a href="#d1e592">GSS-API Naming Considerations</a></li><li>5.3&nbsp;&nbsp;&nbsp;<a href="#d1e613">Representation of LoF/TOFU Principal and Realm Names</a></li><li>5.4&nbsp;&nbsp;&nbsp;<a href="#d1e663">GSS-API Name-Type for Pseudonymous Principals</a><ul><li>5.4.1&nbsp;&nbsp;&nbsp;<a href="#d1e672">Kerberos Name-Type for Pseudonymous Principals</a></li></ul></li></ul></li><li>6.&nbsp;&nbsp;&nbsp;<a href="#d1e681">Security Considerations</a><ul><li>6.1&nbsp;&nbsp;&nbsp;<a href="#d1e694">Loss of Cross-Realm Principal Trust Establishment Information</a></li><li>6.2&nbsp;&nbsp;&nbsp;<a href="#d1e706">Security Considerations for LoF/TOFU</a></li><li>6.3&nbsp;&nbsp;&nbsp;<a href="#d1e727">On the Need for a Common Transit Path Policy Language</a></li></ul></li><li>7.&nbsp;&nbsp;&nbsp;<a href="#d1e740">IANA Considerations</a></li><li>8.&nbsp;&nbsp;&nbsp;<a href="#d1e749">Acknowledgements</a></li><li>9.&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li>9.1&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li>9.2&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.authors">Author's Address</a></li></ul><hr class="noprint"><h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a id="d1e312" href="#d1e312">Introduction</a></h1><p id="rfc.section.1.p.1">Kerberos <a href="#RFC4120"><cite title="The Kerberos Network Authentication Service (V5)">[RFC4120]</cite></a> supports meshes of many realms. The individual relationships between realms must be manually keyed, usually with keys derived from passwords. These keys are very difficult to rollover, and when they are changed the result is often outages -- controlled outages where foreseen, but outages nonetheless. This method of cross-realm keying does not scale, and has very poor security properties. We seek to remediate this.</p><p id="rfc.section.1.p.2">Many years ago there was a proposal for exchanging cross-realm keys using a public key infrastructure (PKI) <a href="#RFC5280"><cite title="Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile">[RFC5280]</cite></a>; that proposal went by the name &#8220;PKCROSS&#8221;. We appropriate that long-dead proposal's name, but the protocol specified here is very different from the original proposal.</p><h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a id="d1e336" href="#d1e336">Conventions used in this document</a></h2><p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p><hr class="noprint"><h1 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a id="d1e352" href="#d1e352">The Protocol</a></h1><p id="rfc.section.2.p.1">A Kerberos client in with a ticket-granting ticket (TGT) for any one source realm (usually but not necessarily the client's own realm) wishing to acquire a TGT for a destination realm may use this protocol instead of the traditional cross-realm ticket-granting service (TGS) exchanges as follows:</p><p id="rfc.section.2.p.2"> </p><ol><li>Generate private key to a public key cryptosystem;</li><li>Generate a certificate signing request (CSR) <a href="#RFC2986"><cite title="PKCS #10: Certification Request Syntax Specification Version 1.7">[RFC2986]</cite></a>, such that the resulting certificate has an id-pkinit-san subject alternative name (SAN) corresponding to the client's principal name and realm;</li><li>Request a certificate from the kx509 <a href="#RFC6717"><cite title="kx509 Kerberized Certificate Issuance Protocol in Use in 2012">[RFC6717]</cite></a> service run by the source realm;</li><li>Request a TGT from the destination realm using PKINIT <a href="#RFC4556"><cite title="Public Key Cryptography for Initial Authentication in Kerberos (PKINIT)">[RFC4556]</cite></a>.</li></ol><p id="rfc.section.2.p.3">If the destination realm issues the requested Ticket then it SHOULD include the client's certificate in an AD-CLIENT-CERTIFICATE authorization-data element, and it MUST do so if it does not validate the client's certificate to an acceptable trust anchor.</p><p id="rfc.section.2.p.4">The destination realm MUST NOT set the TRANSIT-POLICY-CHECKED flag on the tickets they issue to clients whose foreign realm certificates are not validated by the KDC. Destination realm administrators may configure their realms to know specific foreign realm clients' certificates.</p><p id="rfc.section.2.p.5">The destination MUST include the trust path of the client's certificate, if validated, in the 'transited' field of the issued Ticket, using a mapping of the issuer names to the X.500 realm naming style.</p><h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a id="d1e401" href="#d1e401">Exchange of Long-Term Cross-Realm Symmetric Keys</a></h2><p id="rfc.section.2.1.p.1">When the client principal is a TGS principal and its PKINIT AS-REQ protocol data unit (PDU) has the USE-SESSION-KEY-AS-REALM-KEY KDCOptions flag set then the client is requesting that the session key of the ticket issued by the destination realm become the long-term key for the corresponding krbtgt/DESTINATION@SOURCE principal. The destination realm MUST validate the client principal's certificate, building a trust path if need be, and validating it to a trust anchor. The source and destination realm MAY have previously exchange fingerprints of their respective key distribution service (KDC) public keys and/or certificates and/or the source realm's kx509 root or intermediate certification authority (CA), and such previously exchanged material, if any, MUST be used for certificate trust validation.</p><p id="rfc.section.2.1.p.2">Realm administrators should use the procedure to setup symmetric cross-realm keys as necessary to save clients from having to frequently use kx509 and PKINIT as described in the preceding section.</p><p id="rfc.section.2.1.p.3">Where public key infrastructure (PKI) exists allowing this to happen automatically, realms' KDCs MAY be configured to automatically key cross-realm principals for any realms that their source realms' clients request cross-realm TGTs for, but note that this presents a denial of service (DoS) opportunity to the source realm's clients. Source realm KDCs SHOULD only do this when a) they are configured to do so, b) the requesting client principal is in the same realm, and c) the KDC has not spent too much effort recently providing this service (i.e., KDCs should throttle attempts to establish symmetric cross-realm keys in this manner). See also the next section.</p><h3 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1</a>&nbsp;<a id="d1e417" href="#d1e417">Caching of PKCROSS Symmetrically-Keyed Cross-Realm Principals</a></h3><p id="rfc.section.2.1.1.p.1">Realms whose KDCs automatically setup symmetrically-keyed cross-realm principals SHOULD treat these principals as a cache, and SHOULD implement a cache eviction policy. For example, a least-recently-used (LRU) or least-frequently-used (LFU) policy. Otherwise a resource exhaustion DoS attack may be possible. See also the preceding section.</p><h2 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2</a>&nbsp;<a id="d1e426" href="#d1e426">Indication of Preference for/ Required Use of Symmetrically-Keyed Cross-Realm Principals</a></h2><p id="rfc.section.2.2.p.1">A KDC MAY reject a PKINIT/PKCROSS request with a KRB-ERROR indicating that the use of a symmetrically-keyed cross-realm relation is required. This is done using the following error code: &lt;TBD&gt;. The following e-data TD type is used to hold a SEQUENCE OF Realm: &lt;TBD&gt;.</p><p id="rfc.section.2.2.p.2">A KDC MAY accept a PKINIT/PKCROSS request but indicate to the client that a symmetrically-keyed cross-realm relation is preferred. The KDC does this by including a PA-DATA containing a SEQUENCE OF Realm, with the following pa-type: &lt;TBD&gt;.</p><p id="rfc.section.2.2.p.3"> <span class="comment" id="rfc.comment.1">[<a href="#rfc.comment.1" class="smpl">rfc.comment.1</a>: Add an ASN.1 module, even though it will contain only one untagged type consisting of a SEQUENCE OF Realm, and the IANA-assigned values for error code, e-data TD type, and pa-type, plus the import of the RFC4120 module (to get the Realm type).]</span> </p><hr class="noprint"><h1 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a id="d1e441" href="#d1e441">Security Properties</a></h1><p id="rfc.section.3.p.1">The proposed PKCROSS protocol has several useful properties described below.</p><h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a id="d1e450" href="#d1e450">Automated Cross-Realm Keying</a></h2><p id="rfc.section.3.1.p.1">No more manual keying of cross-realm principals via exchanging passwords on a telephone call (or similar).</p><h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a id="d1e459" href="#d1e459">Scalability and Vulnerability to Trusted Third Parties (TTPs)</a></h2><p id="rfc.section.3.2.p.1">Kerberos with commonplace symmetrically-keyed hierarchical cross-real trusts can scale to a large universe of realms, but only if there are top-level realms that are willing to pair-wise trust and &#8220;child&#8221; realms. Such top-level realms do not exist in practice, leading to an O(N^2) scaling problem for most two-label realms. Leveraging a PKI, such as a PKIX PKI <a href="#RFC5280"><cite title="Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile">[RFC5280]</cite></a> or a DNSSEC PKI <a href="#RFC4033"><cite title="DNS Security Introduction and Requirements">[RFC4033]</cite></a> removes the need for either top-level realms (which are not likely to ever be operated as commercial or even non-profit entities) or O(N^2) pair-wise cross-realm symmetric keying. The cost of this is having to add PKI trust paths to Kerberos trust paths (though the resulting trust path length need not be much different than before). Another cost is that having one (or many) top-level / root trusted third party (TTP), makes Kerberos susceptible to attack by those TTPs -- this was, and is, always a problem with any TTP protocol -such as Kerberos and PKI- anyways.</p><h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;<a id="d1e481" href="#d1e481">Privacy Protection relative to home realm</a></h2><p id="rfc.section.3.3.p.1">This protocol protects the privacy of client principals vis-a-vis their home realms: client principals' home realms need not know what destination realms the clients are speaking to because client principals need not ask their home realms.</p><p id="rfc.section.3.3.p.2">This feature is generally and naturally available in PKI, and as this protocol is based on a kerberized certification authority, this protocol inherits this privacy feature from PKI.</p><p id="rfc.section.3.3.p.3">The realms visited by the client may, of course, inform the client's home realm, but in the event that they don't, the client does gain this small measure of privacy. Of course, the client SHOULD attach an OCSP Response <a href="#RFC6960"><cite title="X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP">[RFC6960]</cite></a> to its PKINIT request, per <a href="#RFC4557"><cite title="Online Certificate Status Protocol (OCSP) Support for Public Key Cryptography for Initial Authentication in Kerberos (PKINIT)">[RFC4557]</cite></a>.</p><h2 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4</a>&nbsp;<a id="d1e508" href="#d1e508">Leap-of-Faith (LoF) / Trust-On-First-Use (TOFU)</a></h2><p id="rfc.section.3.4.p.1">Clients need not validate the certificate trust path of destination realms. When they do not, the services used through those destination realms are as good as anonymous authentication. If the client saves the root or intermediate or end entity certificates of the destination realms that it cannot or does not validate, then the client can check that on future occasions the destination realm's certificate has not changed, and it may warn the user if it has. This quite similar to how clients using the secure shell (SSH) protocol <a href="#RFC4251"><cite title="The Secure Shell (SSH) Protocol Architecture">[RFC4251]</cite></a> handle server authentication, and is commonly known as &#8220;leap-of-faith&#8221; (LoF) or trust-on-first-use (TOFU). The result is pseudonymous authentication.</p><p id="rfc.section.3.4.p.2">Destination services too may apply apply LoF/TOFU: by not validating the transit path of the client (e.g., if it's not in a white-list of realms whose clients must have valid transit paths) and accepting tickets without the TRANSITED-POLICY-CHECKED ticket flag set. The destination service can save the client's certificate, if found in an AD-CLIENT-CERTIFICATE authorization-data element in the client's Ticket, and may use it later to ensure that it is talking to the same client.</p><h3 id="rfc.section.3.4.1"><a href="#rfc.section.3.4.1">3.4.1</a>&nbsp;<a id="sub_Requirements_for_LoF_TOFU" href="#sub_Requirements_for_LoF_TOFU">Requirements and Recommendations for LoF/TOFU Authentication</a></h3><p id="rfc.section.3.4.1.p.1"> </p><ul><li>Implementations MUST NOT use LoF/TOFU to authenticate a target service's realm without the approval of the user or without making it clear that the realm is not fully authenticated (perhaps by replacing the realm's name with a fingerprint of its public key / certificate).</li><li>Implementations MAY allow users and/or service administrators to establish user-friendly aliases for peer principal names that include public key fingerprint material.</li><li>Implementations MAY provide a way to automatically learn realm name &lt;-&gt; public key / certificate bindings. Pinning [add reference to HSTS] SHOULD be supported in that case. The user MUST approve of each such mapping.</li></ul><hr class="noprint"><h1 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a id="d1e544" href="#d1e544">Using DANE (DNSSEC) for Realm Certificate Validation</a></h1><p id="rfc.section.4.p.1">It is possible to use DNS-Based Authentication of Named Entities (DANE) <a href="#RFC6698"><cite title="The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA">[RFC6698]</cite></a> to authenticate the KDC certificates of realms with domain-style names. To do this simply format the realm's DOMAIN-style name as a DNS domainname (no case folding is necessary), then format the DANE TLSA resource record set's (RRset) domainname per-DANE, using the KDC's port number. Note that the KDCs will usually not speak TLS, though there is an extension for using TLS in the KDC over TCP protocol <a href="#RFC6251"><cite title="Using Kerberos Version 5 over the Transport Layer Security (TLS) Protocol">[RFC6251]</cite></a>. For example, the TLSA RRset for any KDC for the DESTINATION.EXAMPLE realm might be named _88._tcp.destination.example. Follow DANE TLSA certificate validation procedures to validate the KDC's certificate regardless of whether the certificate was obtained by using PKINIT or TLS.</p><p id="rfc.section.4.p.2">Normal PKINIT KDC certificate validation rules MAY also be used in addition to DANE rules.</p><hr class="noprint"><h1 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a>&nbsp;<a id="d1e569" href="#d1e569">Application Programming Interface Considerations</a></h1><p id="rfc.section.5.p.1">For non-LoF/TOFU uses the main security consideration for applications is that improved scalability for Kerberos realm traversal implies larger Kerberos universes, and the larger a universe of trust the more important it is to have useful and expressive local policy for evaluating the trustworthiness of any given transit path. Because in most applications local policy should be a component external to the application, there is little impact on APIs here. However, an implementation may wish to provide applications with interfaces for specifying policies, either named or by value.</p><h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a>&nbsp;<a id="sub_API_Considerations_for" href="#sub_API_Considerations_for">API Considerations for LoF/TOFU Authentication</a></h2><p id="rfc.section.5.1.p.1">For LoF/TOFU uses there is a critical requirement that APIs not permit accidental aliasing of principal names as a result of LoF/TOFU being used. The simplest way to do this is to use a fingerprint of the peer principal's public key as their principal, and/or a fingerprint of the peer principal's realm's public key as their realm.</p><p id="rfc.section.5.1.p.2"> <span class="comment" id="rfc.comment.2">[<a href="#rfc.comment.2" class="smpl">rfc.comment.2</a>: For interoperability and compatibility we might want to specify what fingerprint algorithm to use, perhaps one of the SSHv2 fingerprint algorithms, such as in RFC4255, but those use weaker hashes...]</span> </p><h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a>&nbsp;<a id="d1e592" href="#d1e592">GSS-API Naming Considerations</a></h2><p id="rfc.section.5.2.p.1">There are no GSS-API-specific considerations. The naming considerations described in <a href="#sub_API_Considerations_for" title="API Considerations for LoF/TOFU Authentication">Section&nbsp;5.1</a> and the naming attributes defined in <a href="#I-D.williams-kitten-generic-naming-attributes"><cite title="Generic Naming Attributes for the Generic Security Services Application Programming Interface (GSS-API)">[I-D.williams-kitten-generic-naming-attributes]</cite></a> are sufficient. Note however that information about how PKCROSS was used to establish symmetrically-keyed cross-realm principals is lost and will not appear in the transit path in tickets issued by KDCs reached via such cross-realm principals.</p><p id="rfc.section.5.2.p.2"> <span class="comment" id="rfc.comment.3">[<a href="#rfc.comment.3" class="smpl">rfc.comment.3</a>: Actually, we may need to specify some interfaces by which to indicate that the user wishes to alias a pseudonymous name. Perhaps we can do so by applying GSS_Set_name_attribute() to a peer MN obtained from GSS_Inquire_context()?]</span> </p><h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3</a>&nbsp;<a id="d1e613" href="#d1e613">Representation of LoF/TOFU Principal and Realm Names</a></h2><p id="rfc.section.5.3.p.1">If there is no acceptable or verifiable trust path for validating a peer's principal's and/or realm's certificate, then the local end-point MUST locally output the peer's principal (or realm) name as a fingerprint of one of:</p><p id="rfc.section.5.3.p.2"> </p><ol><li>peer's EE certificate's subject public key;</li><li>a subject Name or GeneralName from the peer's EE certificate and the peer's certificate issuer's subjectPublicKey.</li></ol><p id="rfc.section.5.3.p.3">The choice of which of the above to fingerprint is a local choice. The default SHOULD be (1). (2) allows for key rollover.</p><p id="rfc.section.5.3.p.4">The fingerprints MUST be computed as follows:</p><p id="rfc.section.5.3.p.5"> </p><ul><li>First format a byte string as follows: <ul><li>for (1) take the subjectPublicKey's DER [add ref to x.690] encoding (this is a BIT STRING), with no additional tagging</li><li>for (2) take the DER encoding of the ASN.1 type &#8220;nameAndIssuerFPInput ::= SEQUENCE { subjectName GeneralName, issuerPublicKey BIT STRING}&#8221;</li></ul> </li><li>Then apply SHA-256 to the octet string from the first step, then take the most significant 192 bits of that hash and base64-encode using the &#8220;URL- and filename-safe alphabet&#8221; <a href="#RFC4648"><cite title="The Base16, Base32, and Base64 Data Encodings">[RFC4648]</cite></a>.</li><li>Prefix &#8220;:spk:&#8221; if using (1) or &#8220;:nai:&#8221; if using (2). This is the fingerprint to use as either the principal name's single component, or as the principal's realm name. If the name is a realm name then the colons (':') in the prefix are to be removed so as to produce valid Kerberos realm names.</li></ul><p id="rfc.section.5.3.p.6">For example, &#8220;:spk:MjNhNjM0YTM4NDFiZDdhNjVkODQ5YTdi&#8221;@FOO.EXAMPLE or &#8220;HTTP/someserver.foo.example@spkMmE1M2RiMjc1Nzk5ODFjNWQwYjk0OTAw&#8221;. Note that all such realm names have no period character ('.') in them and will too long to match top-level domainnames in use in the DNS, and no such principal names have a forward slash ('/') character in them. Note also that interpretation of such principal names as usernames on POSIX systems will either produce an empty string (due to implementation issues regarding the use of colons (':' as separators in POSIX user databases) or the full string, either way not likely ti collide with valid usernames.</p><h2 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4</a>&nbsp;<a id="d1e663" href="#d1e663">GSS-API Name-Type for Pseudonymous Principals</a></h2><p id="rfc.section.5.4.p.1">We add a new GSS-API name-type: GSS_C_NT_PSEUDONYMOUS. This represents principals whose names are pseudonymous.</p><h3 id="rfc.section.5.4.1"><a href="#rfc.section.5.4.1">5.4.1</a>&nbsp;<a id="d1e672" href="#d1e672">Kerberos Name-Type for Pseudonymous Principals</a></h3><p id="rfc.section.5.4.1.p.1">At this time pseudonymous principal names should not appear in Kerberos PDUs, thus no name-type need be assigned. If a pseudonymous name must be appear in a Kerberos PDU for any reason then the NT-UNKNOWN name-type should be used.</p><hr class="noprint"><h1 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a>&nbsp;<a id="d1e681" href="#d1e681">Security Considerations</a></h1><p id="rfc.section.6.p.1"> <span class="comment" id="rfc.comment.4">[<a href="#rfc.comment.4" class="smpl">rfc.comment.4</a>: All the security considerations of Kerberos and PKI apply. Security considerations are discussed throughout this document.]</span> </p><p id="rfc.section.6.p.2">Scaling up the universe of realms reachable via any trust path necessarily dilutes trust overall, but not for specific paths. On the other hand, by shortening transit path lengths trust can be improved, though some short transit paths will have been symmetrically keyed using this PKCROSS protocol and therefore will be longer than they appear to be. These are subjective notions of trust, of course.</p><h2 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1</a>&nbsp;<a id="d1e694" href="#d1e694">Loss of Cross-Realm Principal Trust Establishment Information</a></h2><p id="rfc.section.6.1.p.1">Note that once a cross-realm principal is symmetrically keyed no information about how that keying operation took place will appear in tickets issued by that TGS principal.</p><p id="rfc.section.6.1.p.2">Note also that the Kebreros transit path encodes only realm names (including X.500-style names, thus PKIX certificate subject and issuer names), and lacks any public key information that might be useful for pinning. However, the certificate validation path for each realm in a transit path SHOULD be included in the transit path.</p><h2 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2</a>&nbsp;<a id="d1e706" href="#d1e706">Security Considerations for LoF/TOFU</a></h2><p id="rfc.section.6.2.p.1">LoF/TOFU has additional security considerations. To start there is the obvious susceptibility to peer impersonation / man-in-the-middle (MITM) attacks on initial contact, which is mitigated by the attacker's need to always remain in the middle in order to avoid detection.</p><p id="rfc.section.6.2.p.2">LoF/TOFU require the ability to remember peers' pseudonymous identities -- their public keys (or certificates), otherwise one remains vulnerable to peer impersonation / MITM attacks at all times. This requires synchronization of peer pseudonym databases across multiple devices (where users have multiple devices), which may not always be possible or performed.</p><p id="rfc.section.6.2.p.3">It is critical that existing applications not be broken by the ability to use LoF/TOFU in new Kerberos implementations when those applications are re-linked with newer Kerberos implementations. To ensure this we require the use of public key fingerprints as principal and/or realm names; local mappings of learned pseudonym mappings onto semantically meaningful names are permitted where the user can validate the mapping. But keep in mind that most users never actually do much to verify peers' public keys in any application/protocol that provides LoF/TOFU [references for this would be nice -Nico].</p><p id="rfc.section.6.2.p.4">See <a href="#sub_Requirements_for_LoF_TOFU" title="Requirements and Recommendations for LoF/TOFU Authentication">Section&nbsp;3.4.1</a> for additional requirements for LoF/TOFU authentication.</p><h2 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3</a>&nbsp;<a id="d1e727" href="#d1e727">On the Need for a Common Transit Path Policy Language</a></h2><p id="rfc.section.6.3.p.1">There are no standard ways to express authorization policies for trust transit paths for either Kerberos nor PKI. A standard language for this would be extremely useful. Such a language should allow for the expression of policies for both, clients and services. Such a language should allow for the expression of complex realm/domain/other naming, and should allow for HSTS-style pinning [add references -Nico]. Such a language should allow for multiple paths where desired, and should allow for more than path rejection: it should also allow for reducing the entitlements assigned to a peer/realm for authorization purposes.</p><p id="rfc.section.6.3.p.2">The need for a standard transit path policy expression language is not new, and such a language is broadly and generally needed. Therefore such a language is outside this document's scope.</p><hr class="noprint"><h1 id="rfc.section.7" class="np"><a href="#rfc.section.7">7.</a>&nbsp;<a id="d1e740" href="#d1e740">IANA Considerations</a></h1><p id="rfc.section.7.p.1"> <span class="comment" id="rfc.comment.5">[<a href="#rfc.comment.5" class="smpl">rfc.comment.5</a>: Allocate the new KDCOptions flag (USE-SESSION-KEY-AS-REALM-KEY) and authorization-data element (AD-CLIENT-CERTIFICATE).]</span> </p><hr class="noprint"><h1 id="rfc.section.8" class="np"><a href="#rfc.section.8">8.</a>&nbsp;<a id="d1e749" href="#d1e749">Acknowledgements</a></h1><p id="rfc.section.8.p.1">Although the author arrived at this &#8220;kx509 + PKINIT == PKCROSS&#8221; idea independently, it is not an original idea. Henry Hotz and Jeffrey Altman each conceived the same idea years earlier. It is a relatively obvious idea when taking into account efforts to bridge disparate security mechanisms and credentials infrastructures.</p><hr class="noprint"><h1 id="rfc.references" class="np"><a id="rfc.section.9" href="#rfc.section.9">9.</a> References</h1><h2 class="np" id="rfc.references.1"><a href="#rfc.section.9.1" id="rfc.section.9.1">9.1</a> Normative References</h2><table><tr><td class="reference"><b id="RFC2119">[RFC2119]</b></td><td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>&#8221;, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.</td></tr><tr><td class="reference"><b id="RFC2986">[RFC2986]</b></td><td class="top">Nystrom, M. and B. Kaliski, &#8220;<a href="http://tools.ietf.org/html/rfc2986">PKCS #10: Certification Request Syntax Specification Version 1.7</a>&#8221;, RFC&nbsp;2986, November&nbsp;2000.</td></tr><tr><td class="reference"><b id="RFC4120">[RFC4120]</b></td><td class="top">Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &#8220;<a href="http://tools.ietf.org/html/rfc4120">The Kerberos Network Authentication Service (V5)</a>&#8221;, RFC&nbsp;4120, July&nbsp;2005.</td></tr><tr><td class="reference"><b id="RFC4556">[RFC4556]</b></td><td class="top">Zhu, L. and B. Tung, &#8220;<a href="http://tools.ietf.org/html/rfc4556">Public Key Cryptography for Initial Authentication in Kerberos (PKINIT)</a>&#8221;, RFC&nbsp;4556, June&nbsp;2006.</td></tr><tr><td class="reference"><b id="RFC4557">[RFC4557]</b></td><td class="top">Zhu, L., Jaganathan, K., and N. Williams, &#8220;<a href="http://tools.ietf.org/html/rfc4557">Online Certificate Status Protocol (OCSP) Support for Public Key Cryptography for Initial Authentication in Kerberos (PKINIT)</a>&#8221;, RFC&nbsp;4557, June&nbsp;2006.</td></tr><tr><td class="reference"><b id="RFC4648">[RFC4648]</b></td><td class="top">Josefsson, S., &#8220;<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>&#8221;, RFC&nbsp;4648, October&nbsp;2006.</td></tr><tr><td class="reference"><b id="RFC5280">[RFC5280]</b></td><td class="top">Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &#8220;<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>&#8221;, RFC&nbsp;5280, May&nbsp;2008.</td></tr><tr><td class="reference"><b id="RFC6698">[RFC6698]</b></td><td class="top">Hoffman, P. and J. Schlyter, &#8220;<a href="http://tools.ietf.org/html/rfc6698">The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA</a>&#8221;, RFC&nbsp;6698, August&nbsp;2012.</td></tr><tr><td class="reference"><b id="RFC6717">[RFC6717]</b></td><td class="top">Hotz, H. and R. Allbery, &#8220;<a href="http://tools.ietf.org/html/rfc6717">kx509 Kerberized Certificate Issuance Protocol in Use in 2012</a>&#8221;, RFC&nbsp;6717, August&nbsp;2012.</td></tr><tr><td class="reference"><b id="I-D.williams-kitten-generic-naming-attributes">[I-D.williams-kitten-generic-naming-attributes]</b></td><td class="top">Williams, N., &#8220;<a href="http://tools.ietf.org/html/draft-williams-kitten-generic-naming-attributes-01">Generic Naming Attributes for the Generic Security Services Application Programming Interface (GSS-API)</a>&#8221;, Internet-Draft&nbsp;draft-williams-kitten-generic-naming-attributes-01 (work in progress), August&nbsp;2013.</td></tr></table><h2 id="rfc.references.2"><a href="#rfc.section.9.2" id="rfc.section.9.2">9.2</a> Informative References</h2><table><tr><td class="reference"><b id="RFC4033">[RFC4033]</b></td><td class="top">Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, &#8220;<a href="http://tools.ietf.org/html/rfc4033">DNS Security Introduction and Requirements</a>&#8221;, RFC&nbsp;4033, March&nbsp;2005.</td></tr><tr><td class="reference"><b id="RFC4251">[RFC4251]</b></td><td class="top">Ylonen, T. and C. Lonvick, &#8220;<a href="http://tools.ietf.org/html/rfc4251">The Secure Shell (SSH) Protocol Architecture</a>&#8221;, RFC&nbsp;4251, January&nbsp;2006.</td></tr><tr><td class="reference"><b id="RFC6251">[RFC6251]</b></td><td class="top">Josefsson, S., &#8220;<a href="http://tools.ietf.org/html/rfc6251">Using Kerberos Version 5 over the Transport Layer Security (TLS) Protocol</a>&#8221;, RFC&nbsp;6251, May&nbsp;2011.</td></tr><tr><td class="reference"><b id="RFC6960">[RFC6960]</b></td><td class="top">Santesson, S., Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, &#8220;<a href="http://tools.ietf.org/html/rfc6960">X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP</a>&#8221;, RFC&nbsp;6960, June&nbsp;2013.</td></tr></table><hr class="noprint"><div class="avoidbreak"><h1 id="rfc.authors" class="np"><a href="#rfc.authors">Author's Address</a></h1><address class="vcard"><span class="vcardline"><span class="fn">Nicolas Williams</span><span class="n hidden"><span class="family-name">Williams</span><span class="given-name">Nicolas</span></span></span><span class="org vcardline">Cryptonector, LLC</span><span class="vcardline">EMail: <a href="mailto:nico@cryptonector.com"><span class="email">nico@cryptonector.com</span></a></span></address></div></body></html>