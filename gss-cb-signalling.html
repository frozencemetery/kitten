<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Channel Binding Signalling for the Generic Security Services Application Programming Interface</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Channel Binding Signalling for the Generic Security Services Application Programming Interface">
<meta name="keywords" content="Internet-Draft">
<meta name="generator" content="xml2rfc v1.36 (http://xml.resource.org/)">
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: small; color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: small; font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: small; font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: small; text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">KITTEN</td><td class="header">R. Harwood</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Red Hat</td></tr>
<tr><td class="header">Updates: <a href='http://tools.ietf.org/html/rfc2743'>2743</a>, <a href='http://tools.ietf.org/html/rfc2744'>2744</a> (if&nbsp;approved)</td><td class="header">N. Williams</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">Cryptonector</td></tr>
<tr><td class="header">Expires: December 3, 2018</td><td class="header">June 2018</td></tr>
</table></td></tr></table>
<h1><br />Channel Binding Signalling for the Generic Security Services Application Programming Interface<br />draft-ietf-kitten-channel-bound-flag-03</h1>

<h3>Abstract</h3>

<p>
Channel binding is a technique that allows applications to use a secure
channel at a lower layer without having to use authentication at that
lower layer. The concept of channel binding comes from the Generic
Security Services Application Programming Interface (GSS-API). It turns
out that the semantics commonly implemented are different than those
specified in the base GSS-API RFC (RFC2743), and that that specification
has a serious bug. This document addresses both the inconsistency
as-implemented and the specification bug.
</p>
<p>
This Internet-Draft proposes the addition of a “channel bound” return
flag for the GSS_Init_sec_context() and GSS_Accept_sec_context()
functions. Two behaviors are specified: a default, safe behavior
reflecting existing implementation deployments, and a behavior that is
only safe when the application specifically tells the GSS-API that it
(the application) supports the new behavior. Additional API elements
related to this are also added, including a new security context
establishment API.
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on December 3, 2018.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2018 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#d1e291">1.</a>&nbsp;
Introduction<br />
<a href="#d1e346">1.1.</a>&nbsp;
Design and Future directions<br />
<a href="#d1e398">1.2.</a>&nbsp;
Conventions used in this document<br />
<a href="#d1e413">2.</a>&nbsp;
Channel Binding State Extension<br />
<a href="#d1e440">2.1.</a>&nbsp;
GSS_Create_sec_context()<br />
<a href="#d1e483">2.1.1.</a>&nbsp;
C-Bindings<br />
<a href="#d1e495">2.2.</a>&nbsp;
GSS_Set_context_flags()<br />
<a href="#d1e553">2.2.1.</a>&nbsp;
C-Bindings<br />
<a href="#d1e565">2.3.</a>&nbsp;
Return Flag for Channel Binding State Signalling<br />
<a href="#d1e574">2.3.1.</a>&nbsp;
C-Bindings<br />
<a href="#sub_New_Mechanism_Attribute">2.4.</a>&nbsp;
New Mechanism Attribute<br />
<a href="#d1e605">2.5.</a>&nbsp;
Request Flag for Acceptor Confirmation of Channel Binding<br />
<a href="#d1e620">2.5.1.</a>&nbsp;
C-Bindings<br />
<a href="#d1e636">2.6.</a>&nbsp;
Handling Empty Contexts in Other GSS-API Functions<br />
<a href="#d1e645">3.</a>&nbsp;
Modified Channel Binding Semantics<br />
<a href="#d1e667">4.</a>&nbsp;
Security Considerations<br />
<a href="#d1e688">5.</a>&nbsp;
IANA Considerations<br />
<a href="#rfc.references1">6.</a>&nbsp;
References<br />
<a href="#rfc.references1">6.1.</a>&nbsp;
Normative References<br />
<a href="#rfc.references2">6.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="d1e291"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
The GSS-API <a class='info' href='#RFC2743'>[RFC2743]<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a> supports “channel binding” <a class='info' href='#RFC5056'>[RFC5056]<span> (</span><span class='info'>Williams, N., &ldquo;On the Use of Channel Bindings to Secure Channels,&rdquo; November&nbsp;2007.</span><span>)</span></a>, a technique for detection of man-in-the-middle
(MITM) attacks in secure channels at lower network layers. This facility
is meant to be all-or-nothing: either both the initiator and acceptor
use it and it succeeds, or both must not use it. This has created a
negotiation problem when retrofitting the use of channel binding into
existing application protocols.
</p>
<p>
However, GSS-APIv2u1 <a class='info' href='#RFC2743'>[RFC2743]<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a> does not specify channel
binding behavior when only one party provides provides none.  In
practice, some mechanisms (such as Kerberos <a class='info' href='#RFC4121'>[RFC4121]<span> (</span><span class='info'>Zhu, L., Jaganathan, K., and S. Hartman, &ldquo;The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2,&rdquo; July&nbsp;2005.</span><span>)</span></a>)
ignore channel bindings when the acceptor provides none, but not when
the initiator provides none.  Note that it would be useless to allow
security context establishment to succeed when the initiator does not
provide channel bindings but the acceptor does, at least as long as
there's no outward indication of whether channel binding was used! Since
the GSS-APIv2u1 does not provide any such indication, this document
corrects that flaw.
</p>
<p>
Allowing the connection to succeed when an initiator provides bindings
but an acceptor does not has helped deployment of channel binding in
existing applications: first fix all the initiators, then fix all the
acceptors. But even this technique is insufficient when there are many
clients to fix, such that fixing them all will take a long time.
Additionally, it limits the usefulness of channel bindings, while
allowing the acceptor to provide but not enforce would protect against
man in the middle attacks (for channel binding aware initiators).
</p>
<p>
This document proposes a new method for deployment of channel binding
that allows the feature to be enabled on the acceptor side before fixing
all initiators. If the GSS-API had always had a return flag by which to
indicate channel binding state then we could have had a simpler method
of deploying channel binding: applications check that return flag and
act accordingly (e.g., fail when channel binding is required). We cannot
safely introduce this behavior now without an indication of support by
the application.
</p>
<p>
Additionally, there may be applications where it is important for
initiators to know that acceptors did use channel binding, and even to
know whether a mechanism is capable of indicating as much. We add a
request flag and a mechanism attribute for such applications.
</p>
<a name="d1e346"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Design and Future directions</h3>

<p>
The design for signalling application flag support and empty contexts is
based on the Java Bindings of the GSS-API <a class='info' href='#RFC5653'>[RFC5653]<span> (</span><span class='info'>Upadhyay, M. and S. Malkani, &ldquo;Generic Security Service API Version 2: Java Bindings Update,&rdquo; August&nbsp;2009.</span><span>)</span></a>. This
document begins introduction of additional context inquiry and mutation
functions, which eventually will also allow for simplified stepping to
replace the GSS_Init/Accept_sec_context() loop.
</p>
<a name="d1e398"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Conventions used in this document</h3>

<p>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="d1e413"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Channel Binding State Extension</h3>

<p>
We propose a new return flag for GSS_Init_sec_context() and
GSS_Accept_sec_context(), as well as a pair of functions for a) creating
“empty” security context handles, b) requesting flags and indicating
which flags the application understands. We also add a new mechanism
attribute for supporting channel binding confirmation.
</p>
<p>
C bindings of these extensions are provided along the lines of <a class='info' href='#RFC2744'>[RFC2744]<span> (</span><span class='info'>Wray, J., &ldquo;Generic Security Service API Version 2 : C-bindings,&rdquo; January&nbsp;2000.</span><span>)</span></a> and <a class='info' href='#RFC5587'>[RFC5587]<span> (</span><span class='info'>Williams, N., &ldquo;Extended Generic Security Service Mechanism Inquiry APIs,&rdquo; July&nbsp;2009.</span><span>)</span></a>.
</p>
<p>
In the future we might move more of the many input (and output)
arguments to GSS_Init_sec_context() and GSS_Accept_sec_context() into
mutators on empty security context handles.
</p>
<a name="d1e440"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
GSS_Create_sec_context()</h3>

<p>
Inputs:
</p>
<p>
          </p>
<ul class="text">
<li>
&lt;none&gt;
</li>
</ul><p>
        
</p>
<p>
Outputs:
</p>
<p>
          </p>
<ul class="text">
<li>
major_status INTEGER
</li>
<li>
minor_status INTEGER -- note: mostly useless, but we should keep it
</li>
<li>
context SECURITY CONTEXT -- “empty” security context
</li>
</ul><p>
        
</p>
<p>
Return major status codes:
</p>
<p>
          </p>
<ul class="text">
<li>
GSS_S_COMPLETE indicates success.
</li>
<li>
GSS_S_UNAVAILABLE indicates that memory is not available, for
example.
</li>
<li>
GSS_S_FAILURE indicates a general failure.
</li>
</ul><p>
        
</p>
<p>
This function creates an “empty” security context handle that can be
passed to GSS_Init_sec_context() or GSS_Accept_sec_context() where they
expect GSS_C_NO_CONTEXT.
</p>
<a name="d1e483"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.1"></a><h3>2.1.1.&nbsp;
C-Bindings</h3>

<p>

</p>
<p>
            </p>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> OM_uint32
 gss_create_sec_context(OM_uint32 *minor_status,
                        gss_ctx_id_t *context);</pre></div><p>

          
</p>
<a name="d1e495"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
GSS_Set_context_flags()</h3>

<p>
Inputs:
</p>
<p>
          </p>
<blockquote class="text"><dl>
<dt>context CONTEXT HANDLE</dt>
<dd>
 
</dd>
<dt>req_flags FLAGS</dt>
<dd>
 Requested flags. Applicable to acceptors and initiators.
</dd>
<dt>ret_flags_understood FLAGS</dt>
<dd>
 The set of return flags understood by the caller.
</dd>
</dl></blockquote><p>
        
</p>
<p>
Outputs:
</p>
<p>
          </p>
<ul class="text">
<li>
major_status INTEGER
</li>
<li>
minor_status INTEGER
</li>
</ul><p>
        
</p>
<p>
Return major status codes:
</p>
<p>
          </p>
<ul class="text">
<li>
GSS_S_COMPLETE indicates success.
</li>
<li>
GSS_S_FAILURE indicates a general failure.
</li>
</ul><p>
        
</p>
<p>
This function tells the mechanism (when one is eventually chosen and
invoked) that the application requests the given req_flags and is
prepared to check the flags in the given ret_flags_understood.
Mechanisms SHOULD NOT limit flags returned to those in
ret_flags_understood, but MAY alter behavior accordingly. Initiators can
override the req_flags in their GSS_Init_sec_context() call, but if no
flags are requested there then the req_flags set on the empty context
will be used. GSS_Accept_sec_context() is not required to perform any
action based on req_flags at this time.
</p>
<p>
NOTE: The abstract GSS-API <a class='info' href='#RFC2743'>[RFC2743]<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a> uses individual
elements--one per-flag--instead of a “FLAGS” type. This is unwieldy,
therefore we introduce an abstract type named “FLAGS” to act as a set of
all the request/return flags defined for the abstract GSS-API.
</p>
<a name="d1e553"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2.1"></a><h3>2.2.1.&nbsp;
C-Bindings</h3>

<p>

</p>
<p>
            </p>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> OM_uint32
 gss_set_context_flags(OM_uint32 *minor_status,
                       gss_ctx_id_t context,
                       uint64_t req_flags,
                       uint64_t ret_flags_understood);</pre></div><p>

          
</p>
<a name="d1e565"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Return Flag for Channel Binding State Signalling</h3>

<p>
Whenever both the initiator and the acceptor provide matching channel
bindings to GSS_Init_sec_context() and GSS_Accept_sec_context(),
respectively, then the mechanism SHALL indicate that the context is
channel bound via an output flag, ret_channel_bound_flag, for the
established context. Note that some mechanisms have no way for the
acceptor to signal CB success to the initiator, in which case
GSS_Init_sec_context() MUST NOT output the ret_channel_bound_flag.
</p>
<a name="d1e574"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.1"></a><h3>2.3.1.&nbsp;
C-Bindings</h3>

<p>

</p>
<p>
            </p>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> #define GSS_C_CHANNEL_BOUND_FLAG 2048 /* 0x00000800 */</pre></div><p>

          
</p>
<a name="sub_New_Mechanism_Attribute"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
New Mechanism Attribute</h3>

<p>
          </p>
<ul class="text">
<li>
We add a new mechanism attribute, GSS_C_MA_CBINDING_CONFIRM, to indicate
that the initiator can and always does learn whether the acceptor
application supplied channel bindings (assuming mutual auth has been
requested). Mechanisms advertising this attribute MUST always indicate
acceptor channel bound state to the initiator.
</li>
</ul><p>
        
</p>
<p>
OID assignments TBD.
</p>
<a name="d1e605"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.5"></a><h3>2.5.&nbsp;
Request Flag for Acceptor Confirmation of Channel Binding</h3>

<p>
We add a new request flag for GSS_Init_sec_context(),
req_cb_confirmation_flag, to be used by initiators that insist on
acceptors providing channel bindings. This flag is only of use to
mechanism-negotiation pseudo-mechanisms (e.g., SPNEGO <a class='info' href='#RFC4178'>[RFC4178]<span> (</span><span class='info'>Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, &ldquo;The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism,&rdquo; October&nbsp;2005.</span><span>)</span></a>): if set, the pseudo-mechanism MUST NOT negotiate
any mechanism which lacks the GSS_C_MA_CBINDINGS attribute and SHOULD
prefer to negotiate mechanisms which have the GSS_C_MA_CBINDING_CONFIRM
attribute.
</p>
<a name="d1e620"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.5.1"></a><h3>2.5.1.&nbsp;
C-Bindings</h3>

<p>
Because GSS_C_CHANNEL_BOUND_FLAG is a return flag only, and this flag is
a request flag only, and to save on precious flag bits, we use the same
flag bit assignment for both flags:
</p>
<p>

</p>
<p>
            </p>
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> #define GSS_C_CB_CONFIRM_FLAG 2048 /* 0x00000800 */</pre></div><p>

          
</p>
<a name="d1e636"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.6"></a><h3>2.6.&nbsp;
Handling Empty Contexts in Other GSS-API Functions</h3>

<p>
          GSS_Init_sec_context() and GSS_Accept_sec_context() operate on
          empty security contexts as specified above (i.e., examining
          flags).
        
</p>
<p>
          All other GSS-API functions MUST treat empty contexts as they
          would GSS_C_NO_CONTEXT as well. For most functions, this will
          result in returning GSS status code GSS_S_NO_CONTEXT.
        
</p>
<p>
          GSS_Delete_sec_context() MUST NOT output a context deletion
          token when applied to empty security contexts.
        
</p>
<a name="d1e645"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Modified Channel Binding Semantics</h3>

<p>
The channel binding semantics of the base GSS-API are modified as
follows:
</p>
<p>
        </p>
<ul class="text">
<li>
Whenever both the initiator and acceptor have provided
input_channel_bindings to GSS_Init/Accept_sec_context() and the channel
bindings do not match, then the mechanism MUST fail to establish a
security context token. (This is a restatement of an existing
requirement in the base specification.)
</li>
<li>
Whenever the acceptor application has a) provided channel bindings to
GSS_Accept_sec_context(), and b) not indicated support for the
ret_channel_bound_flag flag, then the mechanism MUST fail to establish a
security context if the initiator did not provide channel bindings data.
This requirement is critical for security purposes, to make applications
predating this document secure, and this requirement reflects actual
implementations as deployed.
</li>
<li>
Whenever the initiator application has a) provided channel bindings to
GSS_Init_sec_context(), and b) not indicated support for the
ret_channel_bound_flag flag, then the mechanism MUST NOT fail to
establish a security context just because the acceptor failed to provide
channel bindings data unless the channel bindings are used for key
derivation. This requirement is for interoperability purposes, and
reflects actual implementations that have been deployed.
</li>
<li>
Whenever the application has a) provided channel bindings to
GSS_Init_sec_context() or GSS_Accept_sec_context(), and b) indicated
support for the ret_channel_bound_flag flag, then the mechanism MUST NOT
fail to establish a security context just because the peer did not
provide channel bindings data unless the channel bindings are used for
key derivation. The mechanism MUST output the ret_channel_bound_flag if
both peers provided the same input_channel_bindings to
GSS_Init_sec_context() and GSS_Accept_sec_context. The mechanism MUST
NOT output the ret_channel_bound_flag if either (or both) peer did not
provide input_channel_bindings to GSS_Init/Accept_sec_context(). This
requirement restores the original base GSS-API specified behavior, with
the addition of the ret_channel_bound_flag flag.
</li>
</ul><p>
      
</p>
<a name="d1e667"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Security Considerations</h3>

<p>
This document deals with security. There are no security considerations
that should be documented separately in this section. To recap, this
document fixes a significant flaw in the base GSS-API <a class='info' href='#RFC2743'>[RFC2743]<span> (</span><span class='info'>Linn, J., &ldquo;Generic Security Service Application Program Interface Version 2, Update 1,&rdquo; January&nbsp;2000.</span><span>)</span></a> specification that fortunately has not been
implemented, and it adds a feature (that should have been in the base
specification) for improved negotiation of use of channel binding <a class='info' href='#RFC5056'>[RFC5056]<span> (</span><span class='info'>Williams, N., &ldquo;On the Use of Channel Bindings to Secure Channels,&rdquo; November&nbsp;2007.</span><span>)</span></a>.
</p>
<a name="d1e688"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
IANA Considerations</h3>

<p>
The GSS-API mechanism attribute is to be added to the “SMI Security for
Mechanism gsscma Codes” registry established by RFC5587 <a class='info' href='#RFC5587'>[RFC5587]<span> (</span><span class='info'>Williams, N., &ldquo;Extended Generic Security Service Mechanism Inquiry APIs,&rdquo; July&nbsp;2009.</span><span>)</span></a>. See  <a class='info' href='#sub_New_Mechanism_Attribute'>Section&nbsp;2.4<span> (</span><span class='info'>New Mechanism Attribute</span><span>)</span></a>.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>6.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text">Bradner, S., &ldquo;<a href="https://www.rfc-editor.org/info/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, DOI&nbsp;10.17487/RFC2119, March&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2743">[RFC2743]</a></td>
<td class="author-text">Linn, J., &ldquo;<a href="https://www.rfc-editor.org/info/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>,&rdquo; RFC&nbsp;2743, DOI&nbsp;10.17487/RFC2743, January&nbsp;2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2744">[RFC2744]</a></td>
<td class="author-text">Wray, J., &ldquo;<a href="https://www.rfc-editor.org/info/rfc2744">Generic Security Service API Version 2 : C-bindings</a>,&rdquo; RFC&nbsp;2744, DOI&nbsp;10.17487/RFC2744, January&nbsp;2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5056">[RFC5056]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="https://www.rfc-editor.org/info/rfc5056">On the Use of Channel Bindings to Secure Channels</a>,&rdquo; RFC&nbsp;5056, DOI&nbsp;10.17487/RFC5056, November&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5587">[RFC5587]</a></td>
<td class="author-text">Williams, N., &ldquo;<a href="https://www.rfc-editor.org/info/rfc5587">Extended Generic Security Service Mechanism Inquiry APIs</a>,&rdquo; RFC&nbsp;5587, DOI&nbsp;10.17487/RFC5587, July&nbsp;2009.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>6.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC4178">[RFC4178]</a></td>
<td class="author-text">Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, &ldquo;<a href="https://www.rfc-editor.org/info/rfc4178">The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism</a>,&rdquo; RFC&nbsp;4178, DOI&nbsp;10.17487/RFC4178, October&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4121">[RFC4121]</a></td>
<td class="author-text">Zhu, L., Jaganathan, K., and S. Hartman, &ldquo;<a href="https://www.rfc-editor.org/info/rfc4121">The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2</a>,&rdquo; RFC&nbsp;4121, DOI&nbsp;10.17487/RFC4121, July&nbsp;2005.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5653">[RFC5653]</a></td>
<td class="author-text">Upadhyay, M. and S. Malkani, &ldquo;<a href="https://www.rfc-editor.org/info/rfc5653">Generic Security Service API Version 2: Java Bindings Update</a>,&rdquo; RFC&nbsp;5653, DOI&nbsp;10.17487/RFC5653, August&nbsp;2009.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Robbie Harwood</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Red Hat, Inc.</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:rharwood@redhat.com">rharwood@redhat.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nicolas Williams</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cryptonector, LLC</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:nico@cryptonector.com">nico@cryptonector.com</a></td></tr>
</table>
</body></html>
