<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en"><head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/"><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>Boundary Analysis for Internationalization and Localization</title><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: verdana, helvetica, arial, sans-serif;
  font-size: 10pt;
  margin-right: 2em;
}
cite {
  font-style: normal;
}
dl {
  margin-left: 2em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dt {
  margin-top: .5em;
}
h1 {
  font-size: 14pt;
  line-height: 21pt;
  page-break-after: avoid;
}
h1.np {
  page-break-before: always;
}
h1 a {
  color: #333333;
}
h2 {
  font-size: 12pt;
  line-height: 15pt;
  page-break-after: avoid;
}
h3, h4, h5, h6 {
  font-size: 10pt;
  page-break-after: avoid;
}
h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
}
ol {
  margin-left: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
}
pre {
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
  page-break-inside: avoid;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
  width: 69em;
}
pre.inline {
  background-color: white;
  padding: 0em;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
  width: 69em;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 10pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap; 
}
table.header td {
  background-color: gray;
  width: 50%;
}
table.header a {
  color: white;
}
td.reference {
  vertical-align: top;
  white-space: nowrap;
  padding-right: 1em;
}
thead {
  display:table-header-group;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  font-size: 10pt;
  margin-left: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 9pt;
  margin-left: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}

.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 9pt;
}
.filename {
  color: #333333;
  font-weight: bold;
  font-size: 12pt;
  line-height: 21pt;
  text-align: center;
}
.fn {
  font-weight: bold;
}
.hidden {
  display: none;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.title {
  color: #990000;
  font-size: 18pt;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
}
.vcardline {
  display: block;
}
.warning {
  font-size: 14pt;
  background-color: yellow;
}


@media print {
  .noprint {
    display: none;
  }
  
  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 12pt;
  }

  ul.toc a::after {
    content: leader('.') target-counter(attr(href), page);
  }
  
  ul.ind li li a {
    content: target-counter(attr(href), page);
  }
  
  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}

@page {
  @top-left {
       content: "Internet-Draft"; 
  } 
  @top-right {
       content: "September 2013"; 
  } 
  @top-center {
       content: "I18N Boundary Analysis"; 
  } 
  @bottom-left {
       content: "Williams"; 
  } 
  @bottom-center {
       content: "Expires March 24, 2014"; 
  } 
  @bottom-right {
       content: "[Page " counter(page) "]"; 
  } 
}

@page:first { 
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction and Motivation" href="#rfc.section.1"><link rel="Chapter" title="2 Internationalization" href="#rfc.section.2"><link rel="Chapter" title="3 Filesystems and Remote/Distributed Filesystem Protocols" href="#rfc.section.3"><link rel="Chapter" title="4 Negotiation Problems" href="#rfc.section.4"><link rel="Chapter" title="5 Remote / Distributed Authentication Protocols and APIs" href="#rfc.section.5"><link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6"><link rel="Chapter" title="7 IANA Considerations" href="#rfc.section.7"><link rel="Chapter" href="#rfc.section.8" title="8 References"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.580, 2012-06-03 11:18:18, XSLT vendor: SAXON 9.1.0.8 from Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dct" href="http://purl.org/dc/terms/"><meta name="dct.creator" content="Williams, N."><meta name="dct.identifier" content="urn:ietf:id:draft-williams-i18n-boundary-analysis-00"><meta name="dct.issued" scheme="ISO8601" content="2013-09-20"><meta name="dct.abstract" content="Internationalization of protocols and programs often requires determining where to use one or another character repertoire, codeset, encoding, where to perform localization, and so on. This document aims to serve as a guide to Internet protocol designers in determining what they may or should recommend or require of protocol implementors. Of particular interest are filesystem protocols."><meta name="description" content="Internationalization of protocols and programs often requires determining where to use one or another character repertoire, codeset, encoding, where to perform localization, and so on. This document aims to serve as a guide to Internet protocol designers in determining what they may or should recommend or require of protocol implementors. Of particular interest are filesystem protocols."></head><body><table class="header"><tbody><tr><td class="left">Network Working Group</td><td class="right">N. Williams</td></tr><tr><td class="left">Internet-Draft</td><td class="right">Cryptonector</td></tr><tr><td class="left">Intended status: Informational</td><td class="right">September 20, 2013</td></tr><tr><td class="left">Expires: March 24, 2014</td><td class="right"></td></tr></tbody></table><p class="title">Boundary Analysis for Internationalization and Localization<br><span class="filename">draft-williams-i18n-boundary-analysis-00</span></p><h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1><p>Internationalization of protocols and programs often requires determining where to use one or another character repertoire, codeset, encoding, where to perform localization, and so on. This document aims to serve as a guide to Internet protocol designers in determining what they may or should recommend or require of protocol implementors. Of particular interest are filesystem protocols.</p><h1><a id="rfc.status" href="#rfc.status">Status of this Memo</a></h1><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as &#8220;work in progress&#8221;.</p><p>This Internet-Draft will expire on March 24, 2014.</p><h1><a id="rfc.copyrightnotice" href="#rfc.copyrightnotice">Copyright Notice</a></h1><p>Copyright © 2013 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p><hr class="noprint"><h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1><ul class="toc"><li>1.&nbsp;&nbsp;&nbsp;<a href="#d1e310">Introduction and Motivation</a><ul><li>1.1&nbsp;&nbsp;&nbsp;<a href="#d1e340">Conventions used in this document</a></li></ul></li><li>2.&nbsp;&nbsp;&nbsp;<a href="#d1e359">Internationalization</a><ul><li>2.1&nbsp;&nbsp;&nbsp;<a href="#d1e390">Terminology</a></li></ul></li><li>3.&nbsp;&nbsp;&nbsp;<a href="#d1e429">Filesystems and Remote/Distributed Filesystem Protocols</a><ul><li>3.1&nbsp;&nbsp;&nbsp;<a href="#d1e450">On Filesystem Client and Server Implementation Architectures and their Relevance</a></li><li>3.2&nbsp;&nbsp;&nbsp;<a href="#sub_Obvious_Boundaries">Obvious Boundaries</a></li><li>3.3&nbsp;&nbsp;&nbsp;<a href="#d1e495">Legacy</a><ul><li>3.3.1&nbsp;&nbsp;&nbsp;<a href="#d1e514">Legacy Problem #1: Loss of Metadata at the System Call Boundary</a></li><li>3.3.2&nbsp;&nbsp;&nbsp;<a href="#d1e523">Legacy Problem #2: Unknown Character String Metadata in Existing Filesystem Content</a></li><li>3.3.3&nbsp;&nbsp;&nbsp;<a href="#d1e532">Legacy Problem #3: Poor Handling of Unicode Equivalence (Normalization)</a></li><li>3.3.4&nbsp;&nbsp;&nbsp;<a href="#d1e548">Legacy Problem #4: Ignored Requirements</a></li><li>3.3.5&nbsp;&nbsp;&nbsp;<a href="#d1e563">Legacy Problem #5: Constraints Imposed by Non-Internet Standards</a></li></ul></li><li>3.4&nbsp;&nbsp;&nbsp;<a href="#d1e582">A World Without Legacy</a></li><li>3.5&nbsp;&nbsp;&nbsp;<a href="#d1e597">Coping with / Accepting Legacy</a><ul><li>3.5.1&nbsp;&nbsp;&nbsp;<a href="#d1e613">Implications</a></li></ul></li><li>3.6&nbsp;&nbsp;&nbsp;<a href="#d1e644">Recommendations for Filesystem Protocols, Filesystems, and Operating Systems</a></li><li>3.7&nbsp;&nbsp;&nbsp;<a href="#d1e728">Interoperability Considerations for Filesystem Protocols</a></li></ul></li><li>4.&nbsp;&nbsp;&nbsp;<a href="#d1e738">Negotiation Problems</a></li><li>5.&nbsp;&nbsp;&nbsp;<a href="#d1e747">Remote / Distributed Authentication Protocols and APIs</a><ul><li>5.1&nbsp;&nbsp;&nbsp;<a href="#d1e756">Kerberos</a></li><li>5.2&nbsp;&nbsp;&nbsp;<a href="#d1e806">SASL</a></li></ul></li><li>6.&nbsp;&nbsp;&nbsp;<a href="#d1e816">Security Considerations</a></li><li>7.&nbsp;&nbsp;&nbsp;<a href="#d1e825">IANA Considerations</a></li><li>8.&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li>8.1&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li>8.2&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.authors">Author's Address</a></li></ul><hr class="noprint"><h1 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a id="d1e310" href="#d1e310">Introduction and Motivation</a></h1><p id="rfc.section.1.p.1">As the IETF has attempted to internationalize Internet protocols we have learned some valuable lessons. It is time to write these down. The author is primarily aware of lessons from internationalization of NFSv4 <a href="#RFC3530"><cite title="Network File System (NFS) version 4 Protocol">[RFC3530]</cite></a> and filesystems in general, as well as Kerberos RFC4120, Simple Authentication and Security Layers (SASL) <a href="#RFC4422"><cite title="Simple Authentication and Security Layer (SASL)">[RFC4422]</cite></a>, and the Generic Security Services Application Programming Interface (GSS-API) <a href="#RFC2743"><cite title="Generic Security Service Application Program Interface Version 2, Update 1">[RFC2743]</cite></a>, therefore that will be the point of departure for this document.</p><p id="rfc.section.1.p.2">This document is INFORMATIVE.</p><h2 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a id="d1e340" href="#d1e340">Conventions used in this document</a></h2><p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.</p><p id="rfc.section.1.1.p.2">Where RFC2119 key words are used herein for stating requirements or recommendations, they are used to as part of suggested normative language to be used by normative Internet protocol specifications that accept the internationalization advice given in this document.</p><hr class="noprint"><h1 id="rfc.section.2" class="np"><a href="#rfc.section.2">2.</a>&nbsp;<a id="d1e359" href="#d1e359">Internationalization</a></h1><p id="rfc.section.2.p.1">Internationalizing a protocol roughly requires the following tasks:</p><p id="rfc.section.2.p.2"> </p><ol><li>decide where to use Unicode [XXX add reference] and what encoding of Unicode</li><li>decide where any conversions to other codesets should be done, if any</li><li>decide what Unicode characters (and non-characters) to permit or forbid</li><li>decide what Unicode character mappings are appropriate</li><li>decide how to handle string equality, including case-sensitive and case-insensitive behavior, and whether and how to handle Unicode equivalence (normalization)</li></ol><p id="rfc.section.2.p.3">In practice, because historically most protocols and data formats do not tag strings with any language nor codeset information, and because codesets and their encodings often overlap, and other legacy problems, there's no simple way to decide where to perform any conversions, mappings, or checks.</p><p id="rfc.section.2.p.4">We describe here our experience with NFSv4 and Kerberos.</p><h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1</a>&nbsp;<a id="d1e390" href="#d1e390">Terminology</a></h2><p id="rfc.section.2.1.p.1">[...]</p><p id="rfc.section.2.1.p.2">Some terms used in this document:</p><p id="rfc.section.2.1.p.3"> </p><dl><dt>just-use-8</dt><dd>Where a program or protocol component accepts character strings, treating them as arbitrary octet strings, often assuming that byte values less than 0x80 are US-ASCII, or that specific byte values are specific US-ASCII characters (e.g., filesystem path component separators).</dd><dt>just-send-8</dt><dd>Where a program or protocol component sends character strings without regard as to whether the string's codeset/encoding are the expected on-the-wire codeset/encoding.</dd><dt>just-use-UTF-8</dt><dd>Where a program or protocol component accepts character strings that are valid UTF-8 strings withour regard to normalization.</dd><dt>just-send-UTF-8</dt><dd>Where a program or protocol component sends UTF-8 character strings without attempting to normalize or perform any similar steps (e.g., applying character mappings and/or prohibitions).</dd><dt>...</dt><dd>Define lots more and reference other RFCs...</dd></dl><hr class="noprint"><h1 id="rfc.section.3" class="np"><a href="#rfc.section.3">3.</a>&nbsp;<a id="d1e429" href="#d1e429">Filesystems and Remote/Distributed Filesystem Protocols</a></h1><p id="rfc.section.3.p.1">Filesystems and filesystem protocols may be the most difficult application to internationalize that we in the IETF have seen to date. Initially, for NFSv4 <a href="#RFC3530"><cite title="Network File System (NFS) version 4 Protocol">[RFC3530]</cite></a> we believed that we could simply mandate the use of UTF-8 <a href="#RFC3629"><cite title="UTF-8, a transformation format of ISO 10646">[RFC3629]</cite></a>, forbid some characters, require a choice of normalization forms, and we'd be done. In practice it was not so simple.</p><h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a id="d1e450" href="#d1e450">On Filesystem Client and Server Implementation Architectures and their Relevance</a></h2><p id="rfc.section.3.1.p.1">To understand the difficulties faced in internationalizing NFSv4 we need to understand the typical architecture of NFSv4 clients and servers. We say &#8220;typical&#8221;, but it really is typical: the vast majority, if not all of the major general-purpose operating systems in use at this time and over the entire history of NFSv4 share the architecture that we describe here, differing only in minor details.</p><p id="rfc.section.3.1.p.2">Normally the architecture and design of clients and servers would be of no interest to the IETF: we want neiter to dictate nor be unduly constrained by such things. In this case architecture and legacy combine to create unusual problems for filesystem protocols. In this case we must take implementation architecture into account!</p><p id="rfc.section.3.1.p.3">Both, clients and servers, typically have a &#8220;kernel&#8221; that executes privileged mode object code and which has a pluggable &#8220;virtual filesystem switch&#8221; (VFS) -- an interface that abstracts filesystems so as to permit support for many different types of filesystems. Clients, and usually servers, also run user-mode object code -less privileged than kernel-mode object code- that interfaces with filesystems by invoking privileged kernel-mode code through well-defined interfaces (&#8220;system calls&#8221;) that allow the kernel to maintain privilege separation and isolation. These system calls too present a common, standard, abstract interface to all filesystems that can be plugged into the kernel's VFS. Some servers run no user-mode object code to speak of, running all fileserver protocol implementations in kernel mode, nonetheless, the architecture is roughly the same for servers as for clients.</p><h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a id="sub_Obvious_Boundaries" href="#sub_Obvious_Boundaries">Obvious Boundaries</a></h2><p id="rfc.section.3.2.p.1">Some boundaries are immediately evident:</p><p id="rfc.section.3.2.p.2"> </p><ul><li>the system call layer, between user-mode and kernel mode</li><li>the VFS boundary, between generic kernel object code and specific filesystem implementations</li><li>the network, between the client implementation and the server implementation</li><li>the VFS again, between the server and the filesystems beneath it</li><li>persistent storage network, between specific filesystem implementations and persistent storage</li></ul><p id="rfc.section.3.2.p.3">Their relevance to I18N will be discussed further below.</p><h2 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;<a id="d1e495" href="#d1e495">Legacy</a></h2><p id="rfc.section.3.3.p.1">Many, perhaps all commonly used general-purpose operating systems, predate modern internationalization efforts. (Some operating systems, such as those for mobile devices, are new enough that they might well pose no legacy I18N issues for filesystems.)</p><p id="rfc.section.3.3.p.2">Most such operating systems simply treated character strings as mostly opaque at many if not all of the boundaries described in <a href="#sub_Obvious_Boundaries" title="Obvious Boundaries">Section&nbsp;3.2</a>, at most interpreting path component separator characters, in the process assuming US-ASCII [XXX add reference] as the lowest common denominator for the purpose of finding path component separators.</p><p id="rfc.section.3.3.p.3">Because these operating systems, filesystem on-disk formats, and actual on-disk filesystems, predate modern internationalization efforts, there exist many filesystems with object name strings of unknown or mixed codesets. Strings, such as object names, in filesystems are never tagged with codeset information because the codeset information was and still is usually lost at the system call boundary. The actual codesets (and encodings) used typically varies along with user (and system administrator) locale preferences.</p><h3 id="rfc.section.3.3.1"><a href="#rfc.section.3.3.1">3.3.1</a>&nbsp;<a id="d1e514" href="#d1e514">Legacy Problem #1: Loss of Metadata at the System Call Boundary</a></h3><p id="rfc.section.3.3.1.p.1">The first and foremost problem, then, is the loss of locale metadata at the system call boundary. Without fixing this we cannot move to an all-Unicode world in filesystems protocols.all</p><h3 id="rfc.section.3.3.2"><a href="#rfc.section.3.3.2">3.3.2</a>&nbsp;<a id="d1e523" href="#d1e523">Legacy Problem #2: Unknown Character String Metadata in Existing Filesystem Content</a></h3><p id="rfc.section.3.3.2.p.1">The second most important problem in filesystem internationalization is the lack of locale (codeset, encoding) metadata for existing (legacy) filesystem content, specifically file and directory names.</p><h3 id="rfc.section.3.3.3"><a href="#rfc.section.3.3.3">3.3.3</a>&nbsp;<a id="d1e532" href="#d1e532">Legacy Problem #3: Poor Handling of Unicode Equivalence (Normalization)</a></h3><p id="rfc.section.3.3.3.p.1">Historically Unicode input methods tend to produce pre-composed codepoints -- something close to Normalization Form Composed (NFC). But this is not always so.</p><p id="rfc.section.3.3.3.p.2">Historically most filesystems treat file (and directory) names as opaque, but at least one filesystem (Apple's HFS+ [XXX add reference]) assumes UTF-8 and normalizes to Normalization Form Decomposed (NFD) at object-create and object-lookup time.</p><p id="rfc.section.3.3.3.p.3">This can result in subtle interoperability problems, as two objects with equivalent names may exist in namespaces (directories) where names are expected to be unique, or users may fail to input names that match those that exist in a filesystem.</p><h3 id="rfc.section.3.3.4"><a href="#rfc.section.3.3.4">3.3.4</a>&nbsp;<a id="d1e548" href="#d1e548">Legacy Problem #4: Ignored Requirements</a></h3><p id="rfc.section.3.3.4.p.1">The original NFSv4 specification <a href="#RFC3530"><cite title="Network File System (NFS) version 4 Protocol">[RFC3530]</cite></a> requires some character mappings and prohibitions. Most implementations have ignored this requirement.</p><h3 id="rfc.section.3.3.5"><a href="#rfc.section.3.3.5">3.3.5</a>&nbsp;<a id="d1e563" href="#d1e563">Legacy Problem #5: Constraints Imposed by Non-Internet Standards</a></h3><p id="rfc.section.3.3.5.p.1">POSIX [XXX add reference] is one common standard for system call interfaces to filesystems. Arguably it requires that:</p><p id="rfc.section.3.3.5.p.2"> </p><ol><li>applications observe the same file/directory names -when listing a directory- as they created;</li><li>no aliases may exist for files/directories that are not &#8220;symlinks&#8221; or &#8220;hardlinks&#8221;.</li></ol><p id="rfc.section.3.3.5.p.3">This makes it very difficult to deploy Unicode normalization anywhere other than the application. But it is not possible to fix every POSIX application to normalize on create or lookup either!</p><h2 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4</a>&nbsp;<a id="d1e582" href="#d1e582">A World Without Legacy</a></h2><p id="rfc.section.3.4.p.1">If we didn't have the legacy problems described above we could simply mandate the use of Unicode in one specific encoding (e.g., UTF-8) &#8220;in the middle&#8221;, with the middle being: from the system call boundary, to the VFS boundary, as well &#8220;on the wire&#8221;. Any codeset conversions and Unicode normalization would be performed at the system call boundary (i.e., on the client) and at the VFS boundary (if, for example, a filesystem on-disk format requires different codeset/encoding than the protocol does on the wire).</p><p id="rfc.section.3.4.p.2">Or perhaps in an ideal world all user applications may run only in Unicode locales, and must perform explicit codeset conversions when handling legacy (non-Unicode) data. This ideal is one we will likely obtain in time, as legacy non-Unicode locales are abandoned, legacy filesystems cleaned up, and new operating systems (or new versions of them) take over older ones.</p><p id="rfc.section.3.4.p.3">In an ideal world there would be no Unicode normalization problems because either there would be just one normal form for Unicode or because all implementations of filesystem clients, servers, filesystems, and filesystem-using applications, would use a single, common normal form. In practice this is almost certainly an impossible ideal.</p><h2 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5</a>&nbsp;<a id="d1e597" href="#d1e597">Coping with / Accepting Legacy</a></h2><p id="rfc.section.3.5.p.1">Legacy abounds. We must cope with it.</p><p id="rfc.section.3.5.p.2">First, the IETF can't cause the system call boundary metadata loss problem to be fixed. The architectures of the relevant operating systems is such that the simplest fix for that problem is to convert between the user-mode locale's codeset/encoding and the codeset/encoding expected by the kernel. But getting such a fix to be implemented and deployed is difficult for a number of reasons, not the least of which is its impact on performance (for users using locales that require conversions), but also complexity: the user-mode side of system calls can sometimes be in a bootstrapping state during which I18N object code may not have been loaded yet. The simplest fix for this problem is to recommend that users use only locales that use Unicode as the charater repertoire and codeset, preferably with the encoding expected on the kernel-side of the system call boundary.</p><p id="rfc.section.3.5.p.3">The second legacy problem -legacy filesystem content- can be addressed by requiring manual inspection and repair of legacy content, but there exist such vast amounts of legacy contents that this is not a realistic option. There is no fix for the legacy filesystem content problem.</p><h3 id="rfc.section.3.5.1"><a href="#rfc.section.3.5.1">3.5.1</a>&nbsp;<a id="d1e613" href="#d1e613">Implications</a></h3><p id="rfc.section.3.5.1.p.1">Some implications of accepting legacy:</p><p id="rfc.section.3.5.1.p.2"> </p><ul><li>we may want Unicode in the middle, but sometimes we'll have non-Unicode content</li><li>we can stop the creation of new non-Unicode content on disk, but we can't really preclude access to it</li><li>normalization-on-create is problematic</li><li>normalization-on-lookup is problematic</li><li>normalization-insensitive lookups are problematic</li><li>ignoring normalization is problematic</li></ul><p id="rfc.section.3.5.1.p.3">With respect to normalization there's no one solution appropriate to all use cases.</p><h2 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6</a>&nbsp;<a id="d1e644" href="#d1e644">Recommendations for Filesystem Protocols, Filesystems, and Operating Systems</a></h2><p id="rfc.section.3.6.p.1"> </p><ul><li>Filesystems SHOULD be configurable to reject object names which are not valid in the filesystem's chosen Unicode encoding. <br><br> This allows filesystems (and their servers) to put a stop to the rot, except, of course, for non-Unicode strings that happen to appear as valid Unicode strings due to codeset/encoding aliasing.</li><li>Remote / distributed filesystem protocols <em>should</em> specify the use of Unicode on the wire, but they should also allow the use of non-Unicode names, leaving it to the filesystem to decide whether to accept or reject such names. <ul><li>For example, this means that NFSv4 <em>servers</em> SHOULD accept object names -from clients- which are not valid UTF-8, contrary to the original NFSv4 specification <a href="#RFC3530"><cite title="Network File System (NFS) version 4 Protocol">[RFC3530]</cite></a>.</li></ul> </li><li>Remote / distributed filesystem protocols should permit servers to return non-Unicode object names to clients. This allows servers to serve legacy non-Unicode content. <ul><li>For example, this means that NFSv4 clients SHOULD be prepared to accept non-UTF-8 names from NFSv4 servers, contrary to the original NFSv4 specification <a href="#RFC3530"><cite title="Network File System (NFS) version 4 Protocol">[RFC3530]</cite></a>.</li></ul> </li><li>Filesystem servers should accept object names -from filesystems- which are not valid in the host operating system's chosen codeset and encoding for use above the VFS.</li><li>Filesystems SHOULD be configurable as to Unicode normalization, allowing at least the following two options: <ul><li>Normalization-insensitive lookups.</li><li>No normalization at all.</li></ul> </li><li>Filesystems MAY be configurable as to Unicode normalization, allowing these additional options: <ul><li>Normalize on create and lookup</li></ul> </li><li>Operating systems SHOULD be configurable as to codeset/encoding conversions at the system call boundary, allowing these options: <ul><li>convert to/from non-Unicode locales' codesets</li><li>no conversion</li></ul> </li><li>Operating systems that do not support codeset/encoding conversions at the system call boundary SHOULD at least encourage users to use or switch to using Unicode locales.</li></ul><h2 id="rfc.section.3.7"><a href="#rfc.section.3.7">3.7</a>&nbsp;<a id="d1e728" href="#d1e728">Interoperability Considerations for Filesystem Protocols</a></h2><p id="rfc.section.3.7.p.1"> <span class="comment" id="rfc.comment.1">[<a href="#rfc.comment.1" class="smpl">rfc.comment.1</a>: Intent: describe interoperability problems that arise given current NFSv4 deployments and legacy filesystem contents.]</span> </p><hr class="noprint"><h1 id="rfc.section.4" class="np"><a href="#rfc.section.4">4.</a>&nbsp;<a id="d1e738" href="#d1e738">Negotiation Problems</a></h1><p id="rfc.section.4.p.1"> <span class="comment" id="rfc.comment.2">[<a href="#rfc.comment.2" class="smpl">rfc.comment.2</a>: Intent: describe the sorts of problems we've had in introducing UTF-8 (or other encodings of Unicode) in protocols where only US-ASCII could be sent initially. For example, in Kerberos we use the ASN.1 type &#8220;IA5-String&#8221;, which can't easily (or at all) be made to carry Unicode content. Other similar problematic cases we could describe include, for example, DNS.]</span> </p><hr class="noprint"><h1 id="rfc.section.5" class="np"><a href="#rfc.section.5">5.</a>&nbsp;<a id="d1e747" href="#d1e747">Remote / Distributed Authentication Protocols and APIs</a></h1><p id="rfc.section.5.p.1"> <span class="comment" id="rfc.comment.3">[<a href="#rfc.comment.3" class="smpl">rfc.comment.3</a>: Intent: describe the problems that arise with security entity identifiers (e.g., user names) that for various reasons need canonicalization (normalization) in protocol components where authoritative canonical naming information is not available (e.g., when usernames are used as salts for cryptographic algorithms without having access to a database or directory that could be used to canonicalize an input username).]</span> </p><h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1</a>&nbsp;<a id="d1e756" href="#d1e756">Kerberos</a></h2><p id="rfc.section.5.1.p.1">Kerberos V5 <a href="#RFC4120"><cite title="The Kerberos Network Authentication Service (V5)">[RFC4120]</cite></a> names two things: principals and realms. Historically only US-ASCII has interoperated well. In practice most implementations just-use-8 and just-send-8, and some just-send-UTF-8 and just-use-UTF-8.</p><p id="rfc.section.5.1.p.2">We considered adding negotiation of the use of non-US-ASCII UTF-8 principal and realm names, but the resulting protocol was quite complex.</p><p id="rfc.section.5.1.p.3">It may soon be time to revisit Kerberos V5 internationalization. Problems to address include:</p><p id="rfc.section.5.1.p.4"> </p><ul><li>how to deal with Kerberos' use of IA5String, which effectively precludes use of Unicode [this is a long story, and we should tell it in detail]: <ul><li>just treat earstwhile IA5String SEQUENCE fields as a CHOICE of IA5String or UTF8String?</li><li>just send UTF-8 as IA5String?</li><li>negotiate support for treating IA5String SEQUENCE fields as CHOICEs of IA5Strign and UTF8String?</li></ul> </li><li>How to deal with normalization? <ul><li>should KDCs treat principal names as normalization-insensitive?</li><li>should principal names used as cryptographic salts be normalized to any particular form?</li><li>should clients and services normalize or treat in a nomalization-form-insensitive manner any principal component and realm names seen in sname/srealm/cname/crealm/transited/and other fields of Ticket, Authenticator, and other Kerberos ASN.1 types?</li></ul> </li></ul><h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2</a>&nbsp;<a id="d1e806" href="#d1e806">SASL</a></h2><p id="rfc.section.5.2.p.1"> <span class="comment" id="rfc.comment.4">[<a href="#rfc.comment.4" class="smpl">rfc.comment.4</a>: Talk about the difference between authentication ID and authorization ID, and the different boundaries for each.]</span> </p><hr class="noprint"><h1 id="rfc.section.6" class="np"><a href="#rfc.section.6">6.</a>&nbsp;<a id="d1e816" href="#d1e816">Security Considerations</a></h1><p id="rfc.section.6.p.1"> <span class="comment" id="rfc.comment.5">[<a href="#rfc.comment.5" class="smpl">rfc.comment.5</a>: Lots to talk about here. For example, aliasing issues w.r.t. multiple equivalent Unicode forms, and the resulting potential for confusion. Also: confusability in general.]</span> </p><hr class="noprint"><h1 id="rfc.section.7" class="np"><a href="#rfc.section.7">7.</a>&nbsp;<a id="d1e825" href="#d1e825">IANA Considerations</a></h1><p id="rfc.section.7.p.1">There are no IANA considerations in this document.</p><hr class="noprint"><h1 id="rfc.references" class="np"><a id="rfc.section.8" href="#rfc.section.8">8.</a> References</h1><h2 class="np" id="rfc.references.1"><a href="#rfc.section.8.1" id="rfc.section.8.1">8.1</a> Normative References</h2><table><tr><td class="reference"><b id="RFC2119">[RFC2119]</b></td><td class="top"><a href="mailto:sob@harvard.edu" title="Harvard University">Bradner, S.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>&#8221;, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.</td></tr></table><h2 id="rfc.references.2"><a href="#rfc.section.8.2" id="rfc.section.8.2">8.2</a> Informative References</h2><table><tr><td class="reference"><b id="RFC3530">[RFC3530]</b></td><td class="top">Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M., and D. Noveck, &#8220;<a href="http://tools.ietf.org/html/rfc3530">Network File System (NFS) version 4 Protocol</a>&#8221;, RFC&nbsp;3530, April&nbsp;2003.</td></tr><tr><td class="reference"><b id="RFC3629">[RFC3629]</b></td><td class="top">Yergeau, F., &#8220;<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>&#8221;, STD&nbsp;63, RFC&nbsp;3629, November&nbsp;2003.</td></tr><tr><td class="reference"><b id="RFC4120">[RFC4120]</b></td><td class="top">Neuman, C., Yu, T., Hartman, S., and K. Raeburn, &#8220;<a href="http://tools.ietf.org/html/rfc4120">The Kerberos Network Authentication Service (V5)</a>&#8221;, RFC&nbsp;4120, July&nbsp;2005.</td></tr><tr><td class="reference"><b id="RFC2743">[RFC2743]</b></td><td class="top"><a href="mailto:jlinn@rsasecurity.com" title="RSA Laboratories">Linn, J.</a>, &#8220;<a href="http://tools.ietf.org/html/rfc2743">Generic Security Service Application Program Interface Version 2, Update 1</a>&#8221;, RFC&nbsp;2743, January&nbsp;2000.</td></tr><tr><td class="reference"><b id="RFC4422">[RFC4422]</b></td><td class="top">Melnikov, A. and K. Zeilenga, &#8220;<a href="http://tools.ietf.org/html/rfc4422">Simple Authentication and Security Layer (SASL)</a>&#8221;, RFC&nbsp;4422, June&nbsp;2006.</td></tr></table><hr class="noprint"><div class="avoidbreak"><h1 id="rfc.authors" class="np"><a href="#rfc.authors">Author's Address</a></h1><address class="vcard"><span class="vcardline"><span class="fn">Nicolas Williams</span><span class="n hidden"><span class="family-name">Williams</span><span class="given-name">Nicolas</span></span></span><span class="org vcardline">Cryptonector, LLC</span><span class="vcardline">EMail: <a href="mailto:nico@cryptonector.com"><span class="email">nico@cryptonector.com</span></a></span></address></div></body></html>